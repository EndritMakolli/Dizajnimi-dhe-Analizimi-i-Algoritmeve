import json

class Node:
    """A node in the Huffman tree."""
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq


def build_frequency_table(text):
    """Builds a frequency dictionary for each character in the text."""
    freq_table = {}
    for char in text:
        freq_table[char] = freq_table.get(char, 0) + 1
    return freq_table


def build_huffman_tree(freq_table):
    """
    Constructs the Huffman tree from the frequency table.
    Uses a min-heap (priority queue).
    """
    import heapq
    heap = []

    # Create a leaf node for each character and push it to the priority queue
    for char, freq in freq_table.items():
        node = Node(char, freq)
        heap.append(node)

    heapq.heapify(heap)

    # Merge nodes until the heap has only one node
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        merged = Node(None, left.freq + right.freq)
        merged.left = left
        merged.right = right

        heapq.heappush(heap, merged)

    return heap[0] if heap else None


def generate_codes(node, prefix="", codes=None):
    """
    Recursively travels the Huffman tree to build the dict of char -> bitstring codes.
    """
    if codes is None:
        codes = {}
    if not node:
        return codes

    # If it's a leaf node, assign the prefix code
    if node.char is not None:
        codes[node.char] = prefix
        return codes

    # Traverse left
    generate_codes(node.left, prefix + "0", codes)
    # Traverse right
    generate_codes(node.right, prefix + "1", codes)
    return codes


def encode_text(text, codes):
    """Encodes the text into a bitstring using the code table."""
    encoded = []
    for char in text:
        encoded.append(codes[char])
    return "".join(encoded)


def decode_text(encoded, codes):
    """
    Decodes a bitstring back to text, given the code table.
    We'll create a reverse lookup from bitstring -> character.
    """
    reverse_codes = {v: k for k, v in codes.items()}
    decoded_chars = []
    current_bits = ""

    for bit in encoded:
        current_bits += bit
        if current_bits in reverse_codes:
            decoded_chars.append(reverse_codes[current_bits])
            current_bits = ""

    return "".join(decoded_chars)


def compress_file(input_path, output_path):
    """
    1) Reads the input file as text
    2) Builds Huffman codes
    3) Encodes the text to a bitstring
    4) Writes both the Huffman code table and compressed bitstring to output_path (binary file)
    """
    # Read the input text
    with open(input_path, 'r', encoding='utf-8', errors='replace') as f:
        text = f.read()

    if not text:
        print(f"Input file '{input_path}' is empty or unreadable.")
        return

    # Build frequency table and Huffman tree
    freq_table = build_frequency_table(text)
    huffman_tree = build_huffman_tree(freq_table)
    codes = generate_codes(huffman_tree)

    # Encode text
    encoded = encode_text(text, codes)

    # Convert the '0'/'1' bitstring into actual bytes
    # Each 8 bits -> 1 byte
    bit_length = len(encoded)
    # Convert to int from base-2, then to bytes
    byte_array = int(encoded, 2).to_bytes((bit_length + 7) // 8, byteorder='big')

    # Prepare code table for writing
    # We'll store it as JSON text
    codes_json = json.dumps(codes, ensure_ascii=False)
    codes_bytes = codes_json.encode('utf-8')

    # Write to output binary file in the following format:
    #   1) 4 bytes: length of the bitstring (int)
    #   2) 4 bytes: length of the serialized code table
    #   3) N bytes: the serialized code table (JSON)
    #   4) remaining bytes: the compressed data
    with open(output_path, 'wb') as f:
        # 1) bitstring length
        f.write(bit_length.to_bytes(4, byteorder='big'))
        # 2) code table length
        f.write(len(codes_bytes).to_bytes(4, byteorder='big'))
        # 3) code table
        f.write(codes_bytes)
        # 4) compressed data
        f.write(byte_array)

    original_size = len(text.encode('utf-8'))  # approximate original size in bytes
    compressed_size = 4 + 4 + len(codes_bytes) + len(byte_array)

    # Print statistics
    print(f"Successfully compressed '{input_path}' to '{output_path}'.")
    print(f"Original size:    {original_size} bytes")
    print(f"Compressed size:  {compressed_size} bytes")
    if original_size > 0:
        ratio = 100.0 * (original_size - compressed_size) / original_size
        print(f"Compression ratio: {ratio:.2f}% size reduction")


def decompress_file(input_path, output_path):
    """
    Reads the compressed .bin file generated by compress_file().
    1) Reads the length of the bitstring (4 bytes).
    2) Reads the length of the code table (4 bytes).
    3) Reads the JSON-serialized code table.
    4) Reads the compressed data and reconstructs the original text.
    5) Writes the text to output_path as UTF-8.
    """
    with open(input_path, 'rb') as f:
        # 1) length of the bitstring
        bit_length = int.from_bytes(f.read(4), byteorder='big')
        # 2) length of the code table
        codes_len = int.from_bytes(f.read(4), byteorder='big')
        # 3) read the code table
        codes_json = f.read(codes_len)
        codes = json.loads(codes_json.decode('utf-8'))

        # 4) read the compressed data
        compressed_data = f.read()

    # Convert the bytes back to a bitstring
    encoded_int = int.from_bytes(compressed_data, byteorder='big')
    encoded_bits = bin(encoded_int)[2:].rjust(bit_length, '0')

    # Decode it
    decoded_text = decode_text(encoded_bits, codes)

    # Write the output file
    with open(output_path, 'w', encoding='utf-8', errors='replace') as f:
        f.write(decoded_text)

    print(f"Successfully decompressed '{input_path}' to '{output_path}'.")
    print(f"Decompressed text length: {len(decoded_text)} characters")


if __name__ == "__main__":
    """
    Example usage:
      python huffman.py compress input.txt output.bin
      python huffman.py decompress output.bin restored.txt
    """
    import sys
    
    if len(sys.argv) < 4:
        print("Usage:")
        print("  python huffman.py compress <input_path> <output_path>")
        print("  python huffman.py decompress <input_path> <output_path>")
        sys.exit(1)
    
    mode = sys.argv[1]
    input_path = sys.argv[2]
    output_path = sys.argv[3]

    if mode == "compress":
        compress_file(input_path, output_path)
    elif mode == "decompress":
        decompress_file(input_path, output_path)
    else:
        print(f"Unknown mode: {mode}")
